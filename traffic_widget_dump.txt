import os
import re
import time
import threading
import tkinter as tk

try:
    import paramiko
except ImportError:
    raise SystemExit("Missing dependency: paramiko. Install via 'pip install paramiko'.")

# Optional tray dependencies
try:
    import pystray
    from PIL import Image, ImageDraw, ImageFont
    HAS_TRAY = True
except Exception:
    HAS_TRAY = False


# Configuration via environment variables (fallback to sensible defaults)
ROUTER_HOST = os.getenv("ROUTER_HOST", "192.168.1.1")
ROUTER_USER = os.getenv("ROUTER_USER", "root")
PASSWORD = os.getenv("PASSWORD", "sauvtm")
SSH_KEY = os.getenv("SSH_KEY", None)  # path to private key, or None
INTERFACE = os.getenv("INTERFACE", "eth0.2")

POLL_INTERVAL = float(os.getenv("POLL_INTERVAL", "1.0"))  # seconds
ALWAYS_ON_TOP = os.getenv("ALWAYS_ON_TOP", "0") in ("1", "true", "True")
START_MINIMIZED = os.getenv("START_MINIMIZED", "0") in ("1", "true", "True")


class RouterMonitor:
    def __init__(self, host, user, password=None, key_filename=None, timeout=5):
        self.host = host
        self.user = user
        self.password = password
        self.key_filename = key_filename
        self.timeout = timeout
        self._ssh = None
        self._lock = threading.Lock()

    def connect(self):
        with self._lock:
            if self._ssh:
                return
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(
                self.host,
                username=self.user,
                password=self.password,
                key_filename=self.key_filename,
                timeout=self.timeout,
                banner_timeout=self.timeout,
                auth_timeout=self.timeout,
            )
            self._ssh = ssh

    def close(self):
        with self._lock:
            if self._ssh:
                try:
                    self._ssh.close()
                finally:
                    self._ssh = None

    def _ensure(self):
        try:
            if not self._ssh:
                self.connect()
            # no-op command to ensure connection is alive (optional)
        except Exception:
            self.close()
            self.connect()

    def read_counters(self, iface):
        self._ensure()
        with self._lock:
            stdin, stdout, stderr = self._ssh.exec_command("cat /proc/net/dev")
            data = stdout.read().decode(errors="ignore")
        # Parse /proc/net/dev
        # Lines look like: '  eth0.2: 123456 0 0 0 0 0 0 0  98765 0 0 0 0 0 0 0'
        target = iface + ":"
        for line in data.splitlines():
            line = line.strip()
            if not line.endswith(":") and target in line.split()[0]:
                try:
                    name, rest = line.split(":", 1)
                    if name.strip() != iface:
                        continue
                    parts = rest.split()
                    rx_bytes = int(parts[0])
                    tx_bytes = int(parts[8])
                    return rx_bytes, tx_bytes
                except Exception:
                    continue
        return None, None


def format_rate_bytes_per_sec(bps):
    # Display in KB/s or MB/s, using decimal multiples (KB=1024)
    if bps is None:
        return "--"
    if bps >= 1024 * 1024:
        return f"{bps / (1024*1024):.2f} MB/s"
    else:
        return f"{bps / 1024:.0f} KB/s"


class TrayManager:
    def __init__(self, on_show, on_exit):
        self.on_show = on_show
        self.on_exit = on_exit
        self.icon = None
        self._thread = None
        self._running = False

    def _make_image(self, down_text, up_text):
        # Create a small 32x32 icon with text
        img = Image.new("RGBA", (32, 32), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)
        try:
            font = ImageFont.load_default()
        except Exception:
            font = None
        # Background rounded rectangle
        draw.rounded_rectangle([0, 0, 31, 31], radius=6, fill=(32, 32, 32, 240))
        # Draw down (blue) and up (green)
        draw.text((3, 4), "D:", fill=(100, 160, 255, 255), font=font)
        draw.text((3, 16), "U:", fill=(120, 220, 120, 255), font=font)
        draw.text((14, 4), down_text, fill=(220, 220, 220, 255), font=font)
        draw.text((14, 16), up_text, fill=(220, 220, 220, 255), font=font)
        return img

    def start(self, title="Traffic", down_text="--", up_text="--"):
        if not HAS_TRAY:
            return
        image = self._make_image(down_text, up_text)
        menu = pystray.Menu(
            pystray.MenuItem("Show", lambda: self.on_show()),
            pystray.MenuItem("Exit", lambda: self.on_exit()),
        )
        self.icon = pystray.Icon("traffic_widget", image, title, menu)
        self._running = True

        def run():
            self.icon.run()

        self._thread = threading.Thread(target=run, daemon=True)
        self._thread.start()

    def update(self, down_bytes_per_s, up_bytes_per_s):
        if not HAS_TRAY or not self.icon:
            return
        # Shorten for tiny icon
        def short(v):
            if v is None:
                return "--"
            if v >= 1024 * 1024:
                return f"{v/(1024*1024):.1f}M"
            else:
                return f"{max(v/1024, 0):.0f}K"

        d = short(down_bytes_per_s)
        u = short(up_bytes_per_s)
        try:
            self.icon.title = f"Down: {format_rate_bytes_per_sec(down_bytes_per_s)} | Up: {format_rate_bytes_per_sec(up_bytes_per_s)}"
            self.icon.icon = self._make_image(d, u)
        except Exception:
            pass

    def stop(self):
        if not HAS_TRAY or not self.icon:
            return
        try:
            self.icon.stop()
        except Exception:
            pass


class App:
    def __init__(self):
        self.monitor = RouterMonitor(ROUTER_HOST, ROUTER_USER, PASSWORD, SSH_KEY)
        self.prev = None  # (rx, tx, t)
        self.stop_event = threading.Event()
        self.lock = threading.Lock()
        self.down_bps = None  # bytes per second
        self.up_bps = None

        # UI
        self.root = tk.Tk()
        self.root.title("Live Traffic")
        self.root.geometry("240x120")
        self.root.resizable(False, False)
        self.root.attributes("-topmost", ALWAYS_ON_TOP)

        self.lbl_rx = tk.Label(self.root, text="↓ --", font=("Segoe UI", 16), fg="blue")
        self.lbl_tx = tk.Label(self.root, text="↑ --", font=("Segoe UI", 16), fg="green")
        self.lbl_rx.pack(pady=(10, 2))
        self.lbl_tx.pack(pady=(0, 6))

        # Controls row
        controls = tk.Frame(self.root)
        controls.pack()
        self.var_topmost = tk.BooleanVar(value=ALWAYS_ON_TOP)
        chk = tk.Checkbutton(controls, text="Always on top", variable=self.var_topmost, command=self.toggle_topmost)
        chk.pack(side=tk.LEFT, padx=6)

        btn_hide = tk.Button(controls, text="Minimize to tray", command=self.minimize_to_tray)
        btn_hide.pack(side=tk.LEFT, padx=6)

        # System tray
        self.tray = TrayManager(self.show_window, self.exit_app)
        if HAS_TRAY:
            self.tray.start()

        # Window events
        self.root.protocol("WM_DELETE_WINDOW", self.minimize_to_tray)
        self.root.bind("<Unmap>", self._on_unmap)

        # Start background polling
        self.thread = threading.Thread(target=self.poll_loop, daemon=True)
        self.thread.start()

        if START_MINIMIZED:
            self.minimize_to_tray()

    def toggle_topmost(self):
        self.root.attributes("-topmost", self.var_topmost.get())

    def minimize_to_tray(self):
        if HAS_TRAY:
            try:
                self.root.withdraw()
            except Exception:
                pass
        else:
            # Fallback: iconify if no tray
            self.root.iconify()

    def show_window(self):
        try:
            self.root.deiconify()
            self.root.after(0, self.root.lift)
        except Exception:
            pass

    def _on_unmap(self, event):
        # When minimized by user, move to tray
        if self.root.state() == 'iconic' and HAS_TRAY:
            self.minimize_to_tray()

    def update_ui(self):
        with self.lock:
            down = self.down_bps
            up = self.up_bps
        self.lbl_rx.config(text=f"↓ {format_rate_bytes_per_sec(down)}")
        self.lbl_tx.config(text=f"↑ {format_rate_bytes_per_sec(up)}")
        if HAS_TRAY:
            self.tray.update(down, up)

    def poll_loop(self):
        # Establish connection lazily on first use
        next_time = time.perf_counter()
        while not self.stop_event.is_set():
            try:
                rx, tx = self.monitor.read_counters(INTERFACE)
                now = time.time()
                if rx is not None and tx is not None:
                    if self.prev is not None:
                        prx, ptx, pt = self.prev
                        dt = max(now - pt, 1e-6)
                        drx = rx - prx
                        dtx = tx - ptx
                        if drx < 0 or dtx < 0:
                            # Counter reset or interface bounce
                            drx = dtx = 0
                        down_bps = drx / dt
                        up_bps = dtx / dt
                        with self.lock:
                            self.down_bps = down_bps
                            self.up_bps = up_bps
                        self.root.after(0, self.update_ui)
                    self.prev = (rx, tx, now)
            except Exception as e:
                # Connection issue; attempt reconnect next loop
                try:
                    self.monitor.close()
                except Exception:
                    pass
            # pacing
            next_time += POLL_INTERVAL
            delay = max(0.0, next_time - time.perf_counter())
            time.sleep(delay)

    def exit_app(self):
        try:
            self.stop_event.set()
            if HAS_TRAY:
                self.tray.stop()
            self.monitor.close()
        finally:
            try:
                self.root.destroy()
            except Exception:
                pass

    def run(self):
        self.root.mainloop()


if __name__ == "__main__":
    app = App()
    app.run()

